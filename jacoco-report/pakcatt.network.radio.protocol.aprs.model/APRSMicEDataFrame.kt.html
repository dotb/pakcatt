<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>APRSMicEDataFrame.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pakcatt</a> &gt; <a href="index.source.html" class="el_package">pakcatt.network.radio.protocol.aprs.model</a> &gt; <span class="el_source">APRSMicEDataFrame.kt</span></div><h1>APRSMicEDataFrame.kt</h1><pre class="source lang-java linenums">package pakcatt.network.radio.protocol.aprs.model

import java.lang.StringBuilder


enum class MIC_E {
    OFF_DUTY, EN_ROUTE, IN_SERVICE, RETURNING, COMMITTED, SPECIAL, PRIORITY, CUSTOM_0,
    CUSTOM_1, CUSTOM_2, CUSTOM_3, CUSTOM_4, CUSTOM_5, CUSTOM_6, EMERGENCY, UNKNOWN
}

/* NOTE - the 101 APRS spec PDF is out of date.
 * The telemetry was abandonded and instead
 * the field is used for compabitility
 * http://www.aprs.org/aprs12/mic-e-types.txt */
enum class RadioCompatibility {
    BEACON,
    MESSAGE,
    UNKNOWN
}

<span class="fc" id="L21">class APRSMicEDataFrame: APRSFrame() {</span>

    // These are manufacture / radio model codes found on the end of a status strings
<span class="fc" id="L24">    private val radioModelCodes = listOf&lt;String&gt;(&quot;v&quot;, &quot;=&quot;, &quot;v&quot;, &quot;=&quot;, &quot;^&quot;, &quot;Mv&quot;, &quot;Mv&quot;, &quot;_b&quot;, &quot;_\&quot;&quot;, &quot;_#&quot;, &quot;_$&quot;,</span>
<span class="fc" id="L25">        &quot;_%&quot;, &quot;_\\)&quot;, &quot;_\\(&quot;, &quot;_0&quot;, &quot;_1&quot;, &quot; X&quot;, &quot;\\(5&quot;, &quot;\\(8&quot;, &quot;|3&quot;, &quot;|4&quot;, &quot;\\v&quot;, &quot;/v&quot;, &quot;^v&quot;, &quot;\\*v&quot;, &quot;:4&quot;, &quot;:8&quot;, &quot;~v&quot;,</span>
<span class="fc" id="L26">        &quot;`v&quot;, &quot;'v&quot;, &quot;/v&quot;, &quot;-v&quot;, &quot;:v&quot;, &quot;;v&quot;, &quot;v&quot;)</span>

    init {
<span class="fc" id="L29">        aprsDataType = APRSDataType.MIC_E_DATA</span>
    }

    fun latitudeDecimalDegreesNorth(): Double {
<span class="fc" id="L33">        val degrees = latitudeDegrees().replace(&quot;?&quot;, &quot;0&quot;).toDouble()</span>
<span class="fc" id="L34">        val minutes = latitudeMinutes().replace(&quot;?&quot;, &quot;0&quot;).toDouble()</span>
<span class="fc" id="L35">        val hundredthsOfAMinute = latitudeHundredths().replace(&quot;?&quot;, &quot;0&quot;).toDouble()</span>
<span class="fc" id="L36">        val latDegrees = degrees + (minutes/60) + (hundredthsOfAMinute/100/60)</span>
<span class="pc bpc" id="L37" title="1 of 2 branches missed.">        return if (latitudeNorthSouth() == &quot;S&quot;) {</span>
<span class="fc" id="L38">            0 - latDegrees</span>
        } else {
<span class="nc" id="L40">            latDegrees</span>
        }
    }

    fun longitudeDecimalDegreesEast(): Double {
<span class="fc" id="L45">        val degrees = longitudeDegrees().replace(&quot;?&quot;, &quot;0&quot;).toDouble()</span>
<span class="fc" id="L46">        val minutes = longitudeMinutes().replace(&quot;?&quot;, &quot;0&quot;).toDouble()</span>
<span class="fc" id="L47">        val hundredthsOfAMinute = longitudeHundredths().replace(&quot;?&quot;, &quot;0&quot;).toDouble()</span>
<span class="fc" id="L48">        val lonDegrees = degrees + (minutes/60) + (hundredthsOfAMinute/100/60)</span>
<span class="pc bpc" id="L49" title="1 of 2 branches missed.">        return if (longitudeWestEast() == &quot;W&quot;) {</span>
<span class="nc" id="L50">            0 - lonDegrees</span>
        } else {
<span class="fc" id="L52">            lonDegrees</span>
        }
    }

    fun latitudeDegreesMinutesHundredths(): String {
<span class="fc" id="L57">        return latitudeDegreesMinutesHundredthsWithAmbiguity().replace(&quot;?&quot;, &quot;0&quot;)</span>
    }

    fun latitudeDegreesMinutesHundredthsWithAmbiguity(): String {
<span class="fc" id="L61">        return &quot;${latitudeDegrees()}.${latitudeMinutes()}.${latitudeHundredths()}${latitudeNorthSouth()}&quot;</span>
    }

    fun latitudeDegrees(): String {
<span class="fc" id="L65">        val firstDigit = decodeDigitForByte(destCallsign[0])</span>
<span class="fc" id="L66">        val secondDigit = decodeDigitForByte(destCallsign[1])</span>
<span class="fc" id="L67">        return &quot;$firstDigit$secondDigit&quot;</span>
    }

    fun latitudeMinutes(): String {
<span class="fc" id="L71">        val firstDigit = decodeDigitForByte(destCallsign[2])</span>
<span class="fc" id="L72">        val secondDigit = decodeDigitForByte(destCallsign[3])</span>
<span class="fc" id="L73">        return &quot;$firstDigit$secondDigit&quot;</span>
    }

    fun latitudeHundredths(): String {
<span class="fc" id="L77">        val firstDigit = decodeDigitForByte(destCallsign[4])</span>
<span class="fc" id="L78">        val secondDigit = decodeDigitForByte(destCallsign[5])</span>
<span class="fc" id="L79">        return &quot;$firstDigit$secondDigit&quot;</span>
    }

    fun latitudeNorthSouth(): String {
<span class="fc" id="L83">        return decodeNorthSouthForByte(destCallsign[3])</span>
    }

    fun longitudeDegreesMinutesHundredths(): String {
<span class="fc" id="L87">        return longitudeDegreesMinutesHundredthsWithAmbiguity().replace(&quot;?&quot;, &quot;0&quot;)</span>
    }

    fun longitudeDegreesMinutesHundredthsWithAmbiguity(): String {
        // Both longitude and latitude values share the same level of ambiguity
<span class="fc" id="L92">        var longitudeString = &quot;${longitudeDegrees()}.${longitudeMinutes()}.${longitudeHundredths()}${longitudeWestEast()}&quot;</span>
<span class="fc" id="L93">        val latitudeString = latitudeDegreesMinutesHundredthsWithAmbiguity()</span>
<span class="fc bfc" id="L94" title="All 2 branches covered.">        for ((index, char) in latitudeString.withIndex()) {</span>
<span class="fc bfc" id="L95" title="All 2 branches covered.">            if (char == '?') {</span>
<span class="pc bpc" id="L96" title="1 of 2 branches missed.">                longitudeString = longitudeString.replaceRange(index + 1, index + 2, &quot;?&quot;)</span>
            }
        }
<span class="fc" id="L99">        return longitudeString</span>
    }

    fun longitudeDegrees(): String {
<span class="fc" id="L103">        val degreesPlusTwentyEight = byteUtils.byteToInt(payloadData[1])</span>
<span class="fc" id="L104">        return decodeLongitudeDegrees(degreesPlusTwentyEight)</span>
    }

    fun longitudeMinutes(): String {
<span class="fc" id="L108">        val minutesPlusTwentyEight = byteUtils.byteToInt(payloadData[2])</span>
<span class="fc" id="L109">        return decodeLongitudeMinutes(minutesPlusTwentyEight)</span>
    }

    fun longitudeHundredths(): String {
<span class="fc" id="L113">        val hundredthsPlusTwentyEight = byteUtils.byteToInt(payloadData[3])</span>
<span class="fc" id="L114">        return decodeLongitudeHundredths(hundredthsPlusTwentyEight)</span>
    }

    fun longitudeWestEast(): String {
<span class="fc" id="L118">        return decodeWestEastForByte(destCallsign[5])</span>
    }

    fun micEType(): MIC_E {
<span class="fc" id="L122">        return decodeMicEForBytes(destCallsign[0], destCallsign[1], destCallsign[2])</span>
    }

    fun longitudeOffset(): Int {
<span class="fc" id="L126">        return decodeLongitudeOffset(destCallsign[4])</span>
    }

    fun speedKnots(): Double {
<span class="fc" id="L130">        return decodeSpeedKnots(byteUtils.byteToInt(payloadData[4]), byteUtils.byteToInt(payloadData[5]))</span>
    }

    fun speedKmh(): Double {
<span class="fc" id="L134">        return speedKnots() * 1.852001</span>
    }

    fun courseDegrees(): Int {
<span class="fc" id="L138">        return decodeDirectionDegrees(byteUtils.byteToInt(payloadData[5]), byteUtils.byteToInt(payloadData[6]))</span>
    }

    fun symbolCode(): String {
<span class="nc" id="L142">        return stringUtils.convertByteToString(payloadData[7])</span>
    }

    fun symbolTableId(): String {
<span class="nc" id="L146">        return stringUtils.convertByteToString(payloadData[8])</span>
    }

    /**
     *  See page 54 of the APRS Spec on telemetry, but note it was abandoned
     *  in favor of defining radio compatibility described here:
     *  http://www.aprs.org/aprs12/mic-e-types.txt
     *  If the 9th byte is:
     *  ‘ = 0x60 = message compatible device
     *  ' = 0x27 = beacon / location only compatible device
     */
    fun radioCompatibility(): RadioCompatibility {
<span class="nc bnc" id="L158" title="All 7 branches missed.">        return when (payloadData[9].toChar()) {</span>
<span class="nc" id="L159">            ' ' -&gt; RadioCompatibility.BEACON</span>
<span class="nc" id="L160">            '\'' -&gt; RadioCompatibility.BEACON</span>
<span class="nc" id="L161">            'T' -&gt; RadioCompatibility.BEACON</span>
<span class="nc" id="L162">            '&gt;' -&gt; RadioCompatibility.MESSAGE</span>
<span class="nc" id="L163">            ']' -&gt; RadioCompatibility.MESSAGE</span>
<span class="nc" id="L164">            '`' -&gt; RadioCompatibility.MESSAGE</span>
<span class="nc" id="L165">            else -&gt; RadioCompatibility.UNKNOWN</span>
        }
    }

    fun hasAltitude(): Boolean {
<span class="pc bpc" id="L170" title="2 of 4 branches missed.">        return payloadData.size &gt;= 14 &amp;&amp; payloadData[13].toChar() == '}'</span>
    }

    fun statusText(): String {
<span class="fc" id="L174">        val payloadString = payloadDataString()</span>
        // The status text starts after the symbol bytes, if there isn't telemetry data then it starts after the telemetry data
<span class="fc" id="L176">        var startIndex = when (hasAltitude()) {</span>
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">            true -&gt; 14</span>
<span class="nc" id="L178">            else -&gt; 10</span>
        }
<span class="fc" id="L180">        val endIndex = payloadString.length - 1</span>

<span class="pc bpc" id="L182" title="1 of 2 branches missed.">        var statusString = if (startIndex &lt; endIndex) {</span>
<span class="pc bpc" id="L183" title="1 of 2 branches missed.">            payloadString.substring(startIndex, endIndex)</span>
        } else {
<span class="nc" id="L185">            &quot;&quot;</span>
        }

        // Clean up any manufacturer / radio model characters from the end of the string
<span class="fc bfc" id="L189" title="All 2 branches covered.">        for (modelStr in radioModelCodes) {</span>
<span class="fc" id="L190">            val regex = &quot;${modelStr}\$&quot;.toRegex()</span>
<span class="fc" id="L191">            statusString = statusString.replace(regex, &quot;&quot;)</span>
        }
<span class="fc" id="L193">        return statusString</span>
    }

    /**
     * Return the ambiguity of the location
     * 0 - no ambiguity
     * 1 or more - the number of digits of ambiguity missing
     * in the lat and lon values
     */
    fun ambiguity(): Int {
<span class="fc" id="L203">        val latitude = latitudeDegreesMinutesHundredthsWithAmbiguity()</span>
<span class="fc bfc" id="L204" title="All 2 branches covered.">        return latitude.count { &quot;?&quot;.contains(it) }</span>
    }

    override fun toString(): String {
<span class="nc" id="L208">        val stringBuilder = StringBuilder()</span>
<span class="nc" id="L209">        stringBuilder.append(&quot;Data Type: $aprsDataType &quot;)</span>
<span class="nc" id="L210">        stringBuilder.append(&quot;From: ${sourceCallsign()} &quot;)</span>
<span class="nc bnc" id="L211" title="All 6 branches missed.">        if (repeaterCallsignOne.isNotEmpty()) {</span>
<span class="nc" id="L212">            stringBuilder.append(&quot;Via1: ${repeaterCallsignOne()} &quot;)</span>
        }

<span class="nc bnc" id="L215" title="All 6 branches missed.">        if (repeaterCallsignTwo.isNotEmpty()) {</span>
<span class="nc" id="L216">            stringBuilder.append(&quot;Via2: ${repeaterCallsignTwo()} &quot;)</span>
        }
<span class="nc" id="L218">        stringBuilder.append(&quot;Lat: ${latitudeDecimalDegreesNorth()} &quot;)</span>
<span class="nc" id="L219">        stringBuilder.append(&quot;Lon: ${longitudeDecimalDegreesEast()} &quot;)</span>
<span class="nc" id="L220">        stringBuilder.append(&quot;Ambiguity: ${ambiguity()} &quot;)</span>
<span class="nc" id="L221">        stringBuilder.append(&quot;Speed: ${speedKmh()}km/h &quot;)</span>
<span class="nc" id="L222">        stringBuilder.append(&quot;Knots: ${speedKnots()} &quot;)</span>
<span class="nc" id="L223">        stringBuilder.append(&quot;Course: ${courseDegrees()} &quot;)</span>
<span class="nc" id="L224">        stringBuilder.append(&quot;Symbol: ${symbolCode()}${symbolTableId()} &quot;)</span>
<span class="nc" id="L225">        stringBuilder.append(&quot;Compat: ${radioCompatibility()} &quot;)</span>
<span class="nc" id="L226">        stringBuilder.append(&quot;Status: ${statusText()}&quot;)</span>
<span class="nc bnc" id="L227" title="All 6 branches missed.">        if (payloadData.isNotEmpty()) {</span>
<span class="nc" id="L228">            stringBuilder.append(&quot; Payload: ${payloadDataString()}&quot;)</span>
        }
<span class="nc" id="L230">        return stringBuilder.toString()</span>
    }

    private fun decodeDigitForByte(rawByte: Byte): String {
<span class="fc" id="L234">        val keyChar = getKeyChar(rawByte)</span>
<span class="fc" id="L235">        return when {</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">            listOf(&quot;0&quot;, &quot;A&quot;, &quot;P&quot;).contains(keyChar) -&gt; &quot;0&quot;</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">            listOf(&quot;1&quot;, &quot;B&quot;, &quot;Q&quot;).contains(keyChar) -&gt; &quot;1&quot;</span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">            listOf(&quot;2&quot;, &quot;C&quot;, &quot;R&quot;).contains(keyChar) -&gt; &quot;2&quot;</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">            listOf(&quot;3&quot;, &quot;D&quot;, &quot;S&quot;).contains(keyChar) -&gt; &quot;3&quot;</span>
<span class="fc bfc" id="L240" title="All 2 branches covered.">            listOf(&quot;4&quot;, &quot;E&quot;, &quot;T&quot;).contains(keyChar) -&gt; &quot;4&quot;</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">            listOf(&quot;5&quot;, &quot;F&quot;, &quot;U&quot;).contains(keyChar) -&gt; &quot;5&quot;</span>
<span class="fc bfc" id="L242" title="All 2 branches covered.">            listOf(&quot;6&quot;, &quot;G&quot;, &quot;V&quot;).contains(keyChar) -&gt; &quot;6&quot;</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">            listOf(&quot;7&quot;, &quot;H&quot;, &quot;W&quot;).contains(keyChar) -&gt; &quot;7&quot;</span>
<span class="fc bfc" id="L244" title="All 2 branches covered.">            listOf(&quot;8&quot;, &quot;I&quot;, &quot;X&quot;).contains(keyChar) -&gt; &quot;8&quot;</span>
<span class="pc bpc" id="L245" title="1 of 2 branches missed.">            listOf(&quot;9&quot;, &quot;J&quot;, &quot;Y&quot;).contains(keyChar) -&gt; &quot;9&quot;</span>
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">            listOf(&quot;K&quot;, &quot;L&quot;, &quot;Z&quot;).contains(keyChar) -&gt; &quot;?&quot; // Space or ambiguous digit</span>
<span class="nc" id="L247">            else -&gt; &quot;?&quot; // Unknown</span>
        }
    }

    private fun decodeNorthSouthForByte(rawByte: Byte): String {
<span class="fc" id="L252">        val keyChar = getKeyChar(rawByte)</span>
<span class="fc" id="L253">        return when {</span>
<span class="pc bpc" id="L254" title="1 of 2 branches missed.">            listOf(&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;L&quot;).contains(keyChar) -&gt; &quot;S&quot;</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">            listOf(&quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;).contains(keyChar) -&gt; &quot;N&quot;</span>
<span class="nc" id="L256">            else -&gt; &quot;?&quot;</span>
        }
    }

    private fun decodeWestEastForByte(rawByte: Byte): String {
<span class="fc" id="L261">        val keyChar = getKeyChar(rawByte)</span>
<span class="fc" id="L262">        return when {</span>
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">            listOf(&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;L&quot;).contains(keyChar) -&gt; &quot;E&quot;</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">            listOf(&quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;).contains(keyChar) -&gt; &quot;W&quot;</span>
<span class="nc" id="L265">            else -&gt; &quot;?&quot;</span>
        }
    }

    /**
     * Decode the MIC-E type. The S and C characters mark 1 bits as standard or custom bits.
     * 1S is a standard 1 bit while 1C is a custom 1 bit. 0 is a 0 bit for both custom and standard
     * MIC-E types.
     */
    private fun decodeMicEForBytes(byteA: Byte, byteB: Byte, byteC: Byte): MIC_E {
<span class="fc" id="L275">        val micBitA = getMicEBitForByte(byteA)</span>
<span class="fc" id="L276">        val micBitB = getMicEBitForByte(byteB)</span>
<span class="fc" id="L277">        val micBitC = getMicEBitForByte(byteC)</span>
<span class="pc bpc" id="L278" title="11 of 16 branches missed.">        return when (&quot;$micBitA$micBitB$micBitC&quot;) {</span>
<span class="nc" id="L279">            &quot;000&quot; -&gt; MIC_E.EMERGENCY</span>
<span class="nc" id="L280">            &quot;001S&quot; -&gt; MIC_E.PRIORITY</span>
<span class="nc" id="L281">            &quot;001C&quot; -&gt; MIC_E.CUSTOM_6</span>
<span class="nc" id="L282">            &quot;01S0&quot; -&gt; MIC_E.SPECIAL</span>
<span class="nc" id="L283">            &quot;01C0&quot; -&gt; MIC_E.CUSTOM_5</span>
<span class="nc" id="L284">            &quot;01S1S&quot; -&gt; MIC_E.COMMITTED</span>
<span class="nc" id="L285">            &quot;01C1C&quot; -&gt; MIC_E.CUSTOM_4</span>
<span class="nc" id="L286">            &quot;1S00&quot; -&gt; MIC_E.RETURNING</span>
<span class="nc" id="L287">            &quot;1C00&quot; -&gt; MIC_E.CUSTOM_3</span>
<span class="fc" id="L288">            &quot;1S01S&quot; -&gt; MIC_E.IN_SERVICE</span>
<span class="nc" id="L289">            &quot;1C01C&quot; -&gt; MIC_E.CUSTOM_2</span>
<span class="fc" id="L290">            &quot;1S1S0&quot; -&gt; MIC_E.EN_ROUTE</span>
<span class="fc" id="L291">            &quot;1C1C0&quot; -&gt; MIC_E.CUSTOM_1</span>
<span class="fc" id="L292">            &quot;1S1S1S&quot; -&gt; MIC_E.OFF_DUTY</span>
<span class="fc" id="L293">            &quot;1C1C1C&quot; -&gt; MIC_E.CUSTOM_0</span>
<span class="nc" id="L294">            else -&gt; MIC_E.UNKNOWN</span>
        }
    }

    /**
     * 0 means 0
     * 1C means the bit is set to 1 for a custom MIC-E
     * 1S means the bit is set to 1 for a standard MIC-E
     */
    private fun getMicEBitForByte(byte: Byte): String {
<span class="fc" id="L304">        val keyChar = getKeyChar(byte)</span>
<span class="fc" id="L305">        return when {</span>
<span class="fc bfc" id="L306" title="All 2 branches covered.">            listOf(&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;L&quot;).contains(keyChar) -&gt; &quot;0&quot;</span>
<span class="fc bfc" id="L307" title="All 2 branches covered.">            listOf(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;).contains(keyChar) -&gt; &quot;1C&quot;</span>
<span class="pc bpc" id="L308" title="1 of 2 branches missed.">            listOf(&quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;).contains(keyChar) -&gt; &quot;1S&quot;</span>
<span class="nc" id="L309">            else -&gt; &quot;0&quot;</span>
        }
    }

    private fun decodeLongitudeOffset(byte: Byte): Int {
<span class="fc" id="L314">        val keyChar = getKeyChar(byte)</span>
<span class="fc" id="L315">        return when {</span>
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">            listOf(&quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;).contains(keyChar) -&gt; 100</span>
<span class="nc" id="L317">            else -&gt; 0</span>
        }
    }

    private fun getKeyChar(byte: Byte): String {
<span class="fc" id="L322">        val shiftedByte = byteUtils.shiftBitsRight(byte, 1)</span>
<span class="fc" id="L323">        return stringUtils.convertByteToString(shiftedByte)</span>
    }

    /**
     * From APRS Spec page 48:
     * To decode the longitude degrees value:
        1. subtract 28 from the d+28 value to obtain d.
        2. if the longitude offset is +100 degrees, add 100 to d.
        3. subtract 80 if 180 &lt;= d &lt;= 189
        (i.e. the longitude is in the range 100–109 degrees).
        4. or, subtract 190 if 190 &lt;= d &lt;= 199.
        (i.e. the longitude is in the range 0–9 degrees).
     */
    private fun decodeLongitudeDegrees(degreesPlusTwentyEight: Int): String {
        // 1. subtract 28 from the d+28 value to obtain d.
<span class="fc" id="L338">        var degrees = degreesPlusTwentyEight - 28</span>

        // 2. if the longitude offset is +100 degrees, add 100 to d.
<span class="fc" id="L341">        degrees += longitudeOffset()</span>

        // 3. subtract 80 if 180 &lt;= d &lt;= 189 (i.e. the longitude is in the range 100–109 degrees).
<span class="pc bpc" id="L344" title="3 of 4 branches missed.">        if (degrees in 180..189) {</span>
<span class="nc" id="L345">            degrees -= 80</span>
<span class="pc bpc" id="L346" title="3 of 4 branches missed.">        } else if (degrees in 190..199) {</span>
            // 4. or, subtract 190 if 190 &lt;= d &lt;= 199. (i.e. the longitude is in the range 0–9 degrees).
<span class="nc" id="L348">            degrees -= 190</span>
        }
<span class="pc bpc" id="L350" title="1 of 2 branches missed.">        return if (degrees &lt;= 9) {</span>
<span class="nc" id="L351">            &quot;0$degrees&quot;</span>
        } else {
<span class="fc" id="L353">            degrees.toString()</span>
        }
    }

    /**
     * * From APRS Spec page 49:
     * To decode the longitude minutes value:
        1. subtract 28 from the m+28 value to obtain m.
        2. subtract 60 if m &gt;= 60.
        (i.e. the longitude minutes is in the range 0–9).
     */
    private fun decodeLongitudeMinutes(minutesPlusTwentyEight: Int): String {
        // 1. subtract 28 from the m+28 value to obtain m.
<span class="fc" id="L366">        var minutes = minutesPlusTwentyEight - 28</span>
        // 2. subtract 60 if m &gt;= 60. (i.e. the longitude minutes is in the range 0–9).
<span class="fc bfc" id="L368" title="All 2 branches covered.">        if (minutes &gt;= 60) {</span>
<span class="fc" id="L369">            minutes -= 60</span>
        }
<span class="fc bfc" id="L371" title="All 2 branches covered.">        return if (minutes &lt;= 9) {</span>
<span class="fc" id="L372">            &quot;0$minutes&quot;</span>
        } else {
<span class="fc" id="L374">            minutes.toString()</span>
        }
    }

    /**
     * From APRS Spec page 49
     * To decode the longitude hundredths of minutes value, subtract 28 from the h+28 value.
     */
    private fun decodeLongitudeHundredths(hundredthsPlusTwentyEight: Int): String {
<span class="fc" id="L383">        val hundredths = hundredthsPlusTwentyEight - 28</span>
<span class="fc bfc" id="L384" title="All 2 branches covered.">        return if (hundredths &lt;= 9) {</span>
<span class="fc" id="L385">            &quot;0$hundredths&quot;</span>
        } else {
<span class="fc" id="L387">            hundredths.toString()</span>
        }
    }

    /**
     * From APRS Spec page 52
     * To decode the speed and course:
        SP+28: To obtain the speed in tens of knots, subtract 28 from the SP+28 value and multiply by 10.
        DC+28: Subtract 28 from the DC+28 value and divide the result by 10. The quotient is the units of speed. The remainder is the course in hundreds of degrees.
        SE+28: To obtain the tens and units of degrees, subtract 28 from the SE+28 value.
        If the computed speed is &gt;= 800 knots, subtract 800.
     */
    private fun decodeSpeedKnots(speedPlusTwentyEight: Int, directionPlusTwentyEight: Int): Double {
        // SP+28: To obtain the speed in tens of knots, subtract 28 from the SP+28 value and multiply by 10.
<span class="fc" id="L401">        var speed = (speedPlusTwentyEight - 28) * 10</span>
        // DC+28: Subtract 28 from the DC+28 value and divide the result by 10. The quotient is the units of speed.
<span class="fc" id="L403">        val speedUnits = (directionPlusTwentyEight - 28) / 10</span>
<span class="fc" id="L404">        speed += speedUnits</span>
        // If the computed speed is &gt;= 800 knots, subtract 800.
<span class="pc bpc" id="L406" title="1 of 2 branches missed.">        return if (speed &gt;= 800) {</span>
<span class="fc" id="L407">            speed.toDouble() - 800</span>
        } else {
<span class="nc" id="L409">            speed.toDouble()</span>
        }
    }

    /**
     * From APRS Spec page 52
     * To decode the speed and course:
        DC+28: Subtract 28 from the DC+28 value and divide the result by 10. The quotient is the units of speed. The remainder is the course in hundreds of degrees.
        SE+28: To obtain the tens and units of degrees, subtract 28 from the SE+28 value.
        If the computed course is &gt;= 400 degrees, subtract 400.
     */
    private fun decodeDirectionDegrees(directionPlusTwentyEight: Int, directionUnitsPlusTwentyEight: Int): Int {
        // DC+28: Subtract 28 from the DC+28 value and divide the result by 10. The remainder is the course in hundreds of degrees.
<span class="fc" id="L422">        var direction = (directionPlusTwentyEight - 28) % 10 * 100</span>

        // SE+28: To obtain the tens and units of degrees, subtract 28 from the SE+28 value.
<span class="fc" id="L425">        val directionTensUnits = directionUnitsPlusTwentyEight - 28</span>
<span class="fc" id="L426">        direction += directionTensUnits</span>
        // If the computed course is &gt;= 400 degrees, subtract 400.
<span class="pc bpc" id="L428" title="1 of 2 branches missed.">        return if (direction &gt;= 400) {</span>
<span class="fc" id="L429">            direction - 400</span>
        } else {
<span class="nc" id="L431">            direction</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>